<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
    />
    <title>Ultimate Projectile Motion Simulation</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
        font-family: "Open Sans", sans-serif;
        background: #1f1f2e;
        color: #f0f0f0;
      }
      body {
        display: flex;
        flex-direction: column;
        padding-bottom: 10px;
      }
      h2 {
        text-align: center;
        margin: 8px 0;
        font-size: 18px;
        color: #ffffff;
        font-weight: 600;
      }
      .main-container {
        width: 95%;
        margin: 10px auto;
        display: flex;
        flex-direction: column; /* Stack on mobile */
        height: calc(100% - 40px);
        gap: 10px;
        padding: 5px;
        box-sizing: border-box;
      }
      /* Desktop layout */
      @media (min-width: 768px) {
        .main-container {
          flex-direction: row;
          gap: 20px;
        }
      }
      .left-panel {
        display: flex;
        flex-direction: column;
        flex: 2;
        gap: 8px;
      }
      #motionInfo {
        background: #2b2b3c;
        border: 1px solid #555;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        margin-bottom: 5px;
        color: #f0f0f0;
        width: 100%;
        box-sizing: border-box;
      }
      #motionInfo span {
        font-weight: bold;
        font-style: italic;
        color: #a8d8ff;
      }
      #simCanvas {
        background: #12122a;
        border: 1px solid #555;
        height: 280px;
        width: 100%;
        box-sizing: border-box;
      }
      .left-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 5px;
      }
      .left-buttons button {
        background: #2b2b3c;
        color: #f0f0f0;
        font-size: 14px;
        border: 1px solid #444;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .left-buttons button:hover {
        background: #3b3b5a;
        border-color: #666;
      }
      .left-buttons button:active {
        background: #4a4a7a;
      }
      .side-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
        overflow-y: auto;
        padding: 5px;
        max-height: 400px; /* Limit height on mobile */
      }
      .controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
      }
      .control {
        background: #2b2b3c;
        border: 1px solid #555;
        padding: 8px;
        border-radius: 6px;
        display: flex;
        flex-direction: column;
        font-size: 12px;
        color: #f0f0f0;
      }
      input[type="range"],
      select {
        width: 100%;
        accent-color: #64b5f6; /* Brighter accent for sliders */
        cursor: pointer;
        background: #3b3b5a;
        color: #f0f0f0;
        border: none;
        padding: 3px;
        border-radius: 3px;
      }
      input[type="checkbox"] {
        cursor: pointer;
        accent-color: #64b5f6;
        margin-right: 5px;
      }
      select {
        background-color: #3b3b5a;
        padding: 4px;
      }
      #graphContainer {
        display: none;
        flex-direction: column;
        gap: 5px;
        margin-top: 10px;
      }
      #graphCanvas {
        width: 100%;
        height: 120px;
        border: 1px solid #555;
        background: #1b1b2e;
        box-sizing: border-box;
      }
      #graphLegend {
        display: flex;
        justify-content: center;
        gap: 15px;
        font-weight: 500;
        font-size: 12px;
        flex-wrap: wrap;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
        color: #f0f0f0;
      }
      .legend-color {
        width: 15px;
        height: 4px;
        border-radius: 2px;
      }
      /* Ground line style */
      .ground-line {
        position: relative;
        top: -3px;
        left: 0;
        width: 100%;
        height: 3px;
        background: #888;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <h2>Projectile Motion Simulation (with Air Resistance)</h2>
    <div class="main-container">
      <div class="left-panel">
        <div id="motionInfo">
          Time: <span id="timeResult">0</span> s | Max Height:
          <span id="heightResult">0</span> m | Range:
          <span id="rangeResult">0</span> m | Impact Speed:
          <span id="impactResult">0</span> m/s
        </div>
        <!-- Add ground line container -->
        <div style="position: relative">
          <canvas id="simCanvas" width="600" height="280"></canvas>
          <div class="ground-line"></div>
        </div>
        <div class="left-buttons">
          <button onclick="startSimulation()">
            <span class="material-symbols-outlined">play_arrow</span> Start
          </button>
          <button id="pauseResumeBtn" onclick="togglePauseResume()" disabled>
            <span class="material-symbols-outlined" id="pauseResumeIcon"
              >pause</span
            >
            Pause
          </button>
          <button onclick="stepSim()">
            <span class="material-symbols-outlined">skip_next</span> Step
          </button>
          <button onclick="resetSimulation()">
            <span class="material-symbols-outlined">refresh</span> Reset
          </button>
        </div>
        <div id="graphContainer">
          <canvas id="graphCanvas" width="600" height="120"></canvas>
          <div id="graphLegend">
            <div class="legend-item">
              <div class="legend-color" style="background: #ff6b6b"></div>
              Kinetic Energy (KE)
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #4ecdc4"></div>
              Potential Energy (PE)
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #ffd166"></div>
              Total Energy
            </div>
          </div>
        </div>
      </div>
      <div class="side-panel">
        <div class="controls">
          <div class="control">
            <label
              ><input type="checkbox" id="airToggle" /> Enable Air
              Resistance</label
            >
          </div>
          <div class="control">
            <label
              ><input type="checkbox" id="graphToggle" /> Show Energy
              Graph</label
            >
          </div>
          <div class="control">
            <label>Initial Speed: <span id="speedVal">50</span> m/s</label
            ><input id="speed" type="range" min="1" max="200" value="50" />
          </div>
          <div class="control">
            <label>Launch Angle: <span id="angleVal">45</span>°</label
            ><input id="angle" type="range" min="0" max="90" value="45" />
          </div>
          <div class="control">
            <label>Mass: <span id="massVal">1</span> kg</label
            ><input
              id="mass"
              type="range"
              min="0.1"
              max="10"
              step="0.1"
              value="1"
            />
          </div>
          <div class="control">
            <label>Drag Coefficient: <span id="dragVal">0</span></label
            ><input
              id="drag"
              type="range"
              min="0"
              max="1"
              step="0.01"
              value="0"
            />
          </div>
          <div class="control">
            <label>Time Step: <span id="dtVal">0.02</span>s</label
            ><input
              id="dt"
              type="range"
              min="0.005"
              max="0.05"
              step="0.005"
              value="0.02"
            />
          </div>
          <div class="control">
            <label>Zoom: <span id="zoomVal">1</span>x</label
            ><input
              id="zoom"
              type="range"
              min="0.5"
              max="3"
              step="0.1"
              value="1"
            />
          </div>
          <div class="control">
            <label>Preset:</label>
            <select id="preset">
              <option value="custom">Custom</option>
              <option value="baseball">Baseball</option>
              <option value="arrow">Arrow</option>
              <option value="cannonball">Cannonball</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <script>
      const simCanvas = document.getElementById("simCanvas");
      const gctx = document.getElementById("graphCanvas").getContext("2d");
      const ctx = simCanvas.getContext("2d");
      const graphContainer = document.getElementById("graphContainer");
      const speed = document.getElementById("speed"),
        angle = document.getElementById("angle"),
        mass = document.getElementById("mass"),
        drag = document.getElementById("drag"),
        airToggle = document.getElementById("airToggle"),
        graphToggle = document.getElementById("graphToggle"),
        dtInput = document.getElementById("dt"),
        zoomInput = document.getElementById("zoom"),
        preset = document.getElementById("preset"),
        pauseResumeBtn = document.getElementById("pauseResumeBtn");

      const speedVal = document.getElementById("speedVal"),
        angleVal = document.getElementById("angleVal"),
        massVal = document.getElementById("massVal"),
        dragVal = document.getElementById("dragVal"),
        dtValLabel = document.getElementById("dtVal"),
        zoomVal = document.getElementById("zoomVal");

      const timeResult = document.getElementById("timeResult"),
        heightResult = document.getElementById("heightResult"),
        rangeResult = document.getElementById("rangeResult"),
        impactResult = document.getElementById("impactResult");

      const G = 9.81; // Gravitational acceleration (m/s²)
      let running = false,
        paused = false;
      let trail = [],
        energyPoints = [];
      let vx = 0,
        vy = 0,
        x = 0,
        y = 0,
        timeT = 0,
        maxHeight = 0,
        dtVal = 0.02,
        zoom = 1;

      // Initialize toggles
      graphToggle.checked = false;
      graphContainer.style.display = "none";
      pauseResumeBtn.disabled = true;

      // Sync air resistance with drag coefficient
      airToggle.addEventListener("change", () => {
        if (airToggle.checked && Number(drag.value) === 0) {
          drag.value = 0.3; // Default drag for air resistance
          updateLabels();
        }
      });

      // Toggle energy graph
      graphToggle.addEventListener("change", () => {
        graphContainer.style.display = graphToggle.checked ? "flex" : "none";
        if (graphToggle.checked) drawGraph(); // Redraw if enabled
      });

      // Update all labels when sliders change
      function updateLabels() {
        speedVal.textContent = Number(speed.value).toFixed(2);
        angleVal.textContent = Number(angle.value).toFixed(1);
        massVal.textContent = Number(mass.value).toFixed(2);
        dragVal.textContent = Number(drag.value).toFixed(2);
        dtValLabel.textContent = Number(dtInput.value).toFixed(3);
        zoomVal.textContent = Number(zoomInput.value).toFixed(2);
      }

      // Attach input listeners to sliders
      [speed, angle, mass, drag, dtInput, zoomInput].forEach((i) =>
        i.addEventListener("input", updateLabels)
      );
      updateLabels();

      // Preset configurations
      preset.addEventListener("change", () => {
        switch (preset.value) {
          case "baseball":
            speed.value = 45;
            angle.value = 35;
            mass.value = 0.145;
            drag.value = 0.35;
            airToggle.checked = true;
            break;
          case "arrow":
            speed.value = 70;
            angle.value = 50;
            mass.value = 0.04;
            drag.value = 0.1;
            airToggle.checked = true;
            break;
          case "cannonball":
            speed.value = 30;
            angle.value = 45;
            mass.value = 6;
            drag.value = 0.47;
            airToggle.checked = true;
            break;
          case "custom":
            // Reset to default custom values
            speed.value = 50;
            angle.value = 45;
            mass.value = 1;
            drag.value = 0;
            break;
        }
        updateLabels();
      });

      // Pause/Resume functionality
      function togglePauseResume() {
        if (!running) return;
        paused = !paused;
        const icon = document.getElementById("pauseResumeIcon");
        icon.textContent = paused ? "play_arrow" : "pause";
        pauseResumeBtn.textContent = paused ? " Resume" : " Pause";
        pauseResumeBtn.prepend(icon); // Keep icon next to text
        if (!paused) requestAnimationFrame(animate);
      }

      // Main animation loop
      function animate() {
        if (!running) return;
        if (!paused) {
          const m = Number(mass.value) || 1,
            c = Number(drag.value) || 0;
          const v = Math.sqrt(vx * vx + vy * vy) || 1e-8; // Avoid division by zero
          let ax = 0,
            ay = -G; // Negative y = upward (canvas coordinate system)

          // Apply air resistance if enabled
          if (airToggle.checked) {
            ax = -(c * v * vx) / m; // Drag opposes velocity
            ay = -G - (c * v * vy) / m;
          }

          // Update velocity and position
          vx += ax * dtVal;
          vy += ay * dtVal;
          x += vx * dtVal;
          y += vy * dtVal;
          timeT += dtVal;

          // Track maximum height
          if (y > maxHeight) maxHeight = y;

          // Calculate energy (for graph)
          const KE = 0.5 * m * (vx * vx + vy * vy);
          const PE = m * G * Math.max(y, 0); // PE can't be negative
          energyPoints.push({ t: timeT, ke: KE, pe: PE, te: KE + PE });

          // Track trail (limit length for performance)
          trail.push({ x, y, vx, vy });
          if (trail.length > 500) trail.shift(); // Keep last 500 points

          // Check if projectile hits the ground (y <= 0)
          if (y < 0) {
            // Update results
            timeResult.textContent = timeT.toFixed(3);
            rangeResult.textContent = x.toFixed(3);
            impactResult.textContent = Math.sqrt(vx * vx + vy * vy).toFixed(3);
            heightResult.textContent = maxHeight.toFixed(3);
            running = false;
            paused = false;
            pauseResumeBtn.disabled = true;
            pauseResumeBtn.innerHTML = '<span class="material-symbols-outlined">pause</span> Pause';
            render();
            drawGraph();
            return;
          }
        }

        // Redraw simulation and graph
        render();
        drawGraph();
        if (!paused) requestAnimationFrame(animate);
      }

      // Start simulation
      function startSimulation() {
        if (running && !paused) return; // Avoid restarting while running
        const v0 = Number(speed.value) || 0,
          ang = (Number(angle.value) * Math.PI) / 180 || 0; // Convert degrees to radians

        // Update simulation parameters
        dtVal = Number(dtInput.value) || 0.02;
        zoom = Number(zoomInput.value) || 1;

        // Reset state
        x = 0;
        y = 0;
        vx = v0 * Math.cos(ang);
        vy = v0 * Math.sin(ang);
        timeT = 0;
        maxHeight = 0;
        trail = [];
        energyPoints = [];
        running = true;
        paused = false;

        // Reset results display
        timeResult.textContent = "0.000";
        heightResult.textContent = "0.000";
        rangeResult.textContent = "0.000";
        impactResult.textContent = "0.000";

        // Enable pause button
        pauseResumeBtn.disabled = false;
        pauseResumeBtn.innerHTML = '<span class="material-symbols-outlined">pause</span> Pause';

        // Start animation
        requestAnimationFrame(animate);
      }

      // Step through simulation one frame
      function stepSim() {
        if (!running) {
          startSimulation();
          paused = true;
          pauseResumeBtn.innerHTML = '<span class="material-symbols-outlined">play_arrow</span> Resume';
          return;
        }
        if (!paused) {
          paused = true;
          pauseResumeBtn.innerHTML = '<span class="material-symbols-outlined">play_arrow</span> Resume';
          return;
        }

        // Calculate one step of physics
        const m = Number(mass.value) || 1,
          c = Number(drag.value) || 0;
        const v = Math.sqrt(vx * vx + vy * vy) || 1e-8;
        let ax = 0,
          ay = -G;

        if (airToggle.checked) {
          ax = -(c * v * vx) / m;
          ay = -G - (c * v * vy) / m;
        }

        // Update state
        vx += ax * dtVal;
        vy += ay * dtVal;
        x += vx * dtVal;
        y += vy * dtVal;
        timeT += dtVal;
        if (y > maxHeight) maxHeight = y;

        // Track trail and energy
        trail.push({ x, y, vx, vy });
        const KE = 0.5 * m * (vx * vx + vy * vy),
          PE = m * G * Math.max(y, 0);
        energyPoints.push({ t: timeT, ke: KE, pe: PE, te: KE + PE });

        // Check for ground impact
        if (y < 0) {
          running = false;
          pauseResumeBtn.disabled = true;
          pauseResumeBtn.innerHTML = '<span class="material-symbols-outlined">pause</span> Pause';
          // Update results
          timeResult.textContent = timeT.toFixed(3);
          rangeResult.textContent = x.toFixed(3);
          impactResult.textContent = Math.sqrt(vx * vx + vy * vy).toFixed(3);
          heightResult.textContent = maxHeight.toFixed(3);
        }

        // Redraw
        render();
        drawGraph();
      }

      // Reset simulation to initial state
      function resetSimulation() {
        running = false;
        paused = false;
        trail = [];
        energyPoints = [];
        x = 0;
        y = 0;
        vx = 0;
        vy = 0;
        timeT = 0;
        maxHeight = 0;

        // Reset UI
        timeResult.textContent = "0.000";
        heightResult.textContent = "0.000";
        rangeResult.textContent = "0.000";
        impactResult.textContent = "0.000";
        pauseResumeBtn.disabled = true;
        pauseResumeBtn.innerHTML = '<span class="material-symbols-outlined">pause</span> Pause';
        ctx.clearRect(0, 0, simCanvas.width, simCanvas.height);
        gctx.clearRect(0, 0, gctx.canvas.width, gctx.canvas.height);
      }

      // Render simulation (projectile, trail, velocity vector)
      function render() {
        ctx.clearRect(0, 0, simCanvas.width, simCanvas.height);

        // Draw trail (semi-transparent for clarity)
        if (trail.length > 1) {
          ctx.strokeStyle = "rgba(78, 205, 196, 0.6)"; // Light blue
          ctx.lineWidth = 2;
          ctx.beginPath();
          trail.forEach((p, i) => {
            const px = p.x * zoom;
            const py = simCanvas.height - p.y * zoom; // Flip y-axis for canvas
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          });
          ctx.stroke();
        }

        // Draw projectile
        if (trail.length > 0) {
          const last = trail[trail.length - 1];
          const px = last.x * zoom;
          const py = simCanvas.height - last.y * zoom;

          // Projectile body
          ctx.fillStyle = "#ff6b6b"; // Red
          ctx.beginPath();
          ctx.arc(px, py, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 1;
          ctx.stroke();

          // Draw velocity vector (scaled for visibility)
          const vectorScale = 0.3 * zoom; // Adjust scale with zoom
          ctx.strokeStyle = "rgba(255, 209, 102, 0.8)"; // Yellow
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(
            px + last.vx * vectorScale,
            py - last.vy * vectorScale // Flip y for velocity (up = positive)
          );
          ctx.stroke();

          // Vector arrowhead
          const arrowLength = 8 * zoom;
          const angle = Math.atan2(-last.vy, last.vx); // Match canvas coordinates
          ctx.beginPath();
          ctx.moveTo(px + last.vx * vectorScale, py - last.vy * vectorScale);
          ctx.lineTo(
            px + last.vx * vectorScale - arrowLength * Math.cos(angle - Math.PI / 6),
            py - last.vy * vectorScale - arrowLength * Math.sin(angle - Math.PI / 6)
          );
          ctx.moveTo(px + last.vx * vectorScale, py - last.vy * vectorScale);
          ctx.lineTo(
            px + last.vx * vectorScale - arrowLength * Math.cos(angle + Math.PI / 6),
            py - last.vy * vectorScale - arrowLength * Math.sin(angle + Math.PI / 6)
          );
          ctx.stroke();
        }
      }

      // Draw energy graph
      function drawGraph() {
        if (!graphToggle.checked || energyPoints.length < 2) {
          gctx.clearRect(0, 0, gctx.canvas.width, gctx.canvas.height);
          return;
        }

        gctx.clearRect(0, 0, gctx.canvas.width, gctx.canvas.height);
        const w = gctx.canvas.width,
          h = gctx.canvas.height;
        const padding = 15; // Add padding to avoid clipping
        const graphW = w - 2 * padding;
        const graphH = h - 2 * padding;

        // Find max values for scaling
        const maxT = energyPoints[energyPoints.length - 1].t || 1e-8;
        const maxE = Math.max(
          1e-8,
          ...energyPoints.map((p) => Math.max(p.ke, p.pe, p.te))
        );

        // Draw grid lines (light gray)
        gctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
        gctx.lineWidth = 1;
        // Vertical grid (every 20% of time)
        for (let i = 0; i <= 5; i++) {
          const x = padding + (i / 5) * graphW;
          gctx.beginPath();
          gctx.moveTo(x, padding);
          gctx.lineTo(x, padding + graphH);
          gctx.stroke();
        }
        // Horizontal grid (every 20% of energy)
        for (let i = 0; i <= 5; i++) {
          const y = padding + (i / 5) * graphH;
          gctx.beginPath();
          gctx.moveTo(padding, y);
          gctx.lineTo(padding + graphW, y);
          gctx.stroke();
        }

        // Draw data lines
        const plotLine = (color, key) => {
          gctx.strokeStyle = color;
          gctx.lineWidth = 2;
          gctx.beginPath();
          energyPoints.forEach((p, i) => {
            // Scale time to x-axis
            const px = padding + (p.t / maxT) * graphW;
            // Scale energy to y-axis (flip for canvas coordinates)
            const py = padding + graphH - (p[key] / maxE) * graphH;

            if (isFinite(px) && isFinite(py)) {
              if (i === 0) gctx.moveTo(px, py);
              else gctx.lineTo(px, py);
            }
          });
          gctx.stroke();
        };

        // Plot each energy type
        plotLine("#ff6b6b", "ke"); // Kinetic Energy (red)
        plotLine("#4ecdc4", "pe"); // Potential Energy (teal)
        plotLine("#ffd166", "te"); // Total Energy (yellow)
      }

      // Handle window resize (optional, but improves usability)
      window.addEventListener("resize", () => {
        // Adjust canvas sizes if needed (keep aspect ratio)
        const newWidth = Math.min(window.innerWidth * 0.6, 800);
        simCanvas.width = newWidth;
        graphCanvas.width = newWidth;
        render();
        drawGraph();
      });
    </script>
  </body>
</html>